\section{Attacking The ATmega}
\label{sec:attacking_mega}

In this section we present the suggested attack that should work against the ATmega644. We believe that someone with a modest level of competence in electronics could successfully bypass the security fuse and lock-bit protections on the ATmega644 board, as researches have succeeded in bypassing the protection imposed by the AVR family in numerous ways. All researches used non-invasive attacks in order to achieve this since there is no need for more sophisticated attacks.Clock glitch attacks against AVR chips were successfully applied by Balasch et al. \citep{glitches_paper} against an ATmega163 and by O'Flynn et al. \citep{chipwhisperer} against an ATmega328P and Kizhvatov \citep{avr_mega} managed to retrieve AES and DES cryptographic keys from an ATmega16 and ATXmega128A1. Furthermore, Skorobogatov \citep{sergei:thesis} also points out that AVR MCUs are susceptible to glitch attacks due to the implementation of their security fuses. 

The suggested attack method will closely follow Balasch et al. \citep{glitches_paper}, further supported by results from other research as well. We will be a Class-I attacker performing a non-invasive clock-glitch attack. The equipment we have access can be found in any descent university's electronics laboratory and our information regarding the chip will come from datasheets. We believe that the attack engineered by Balasch et al. \citep{glitches_paper} on the ATmega163 can be ported over to the ATmega644 due to their similarities. Both devices belong to the same family and by comparing their datasheets we can see that the 644 possesses all the hardware features that make the attack possible on the 163, namely it operates on an external clock signal and has a two stage pipeline\citep{glitches_paper}. Furthermore, the two devices have an almost identical, small, instruction set.

The attack should be tailored to a particular goal and hence we should distinguish the task of recovering cryptographic material from the task of executing unintended instructions, including revealing memory contents. In both cases monitoring the device's power consumption will help us gain some insight into what the device is doing, like in Fig.~\ref{fig:des_power}, and will furthermore allow us to synchronize with the device's operations \citep{sergei:thesis}\citep{avr_mega}. 

Performing a clock-glitch attack for corrupting the execution of the instruction flow or the data being manipulated by the ATmega644 would require locating when this happens and then exploiting it. Subtleties that should be noted include that the glitch attack should be synchronized with the devices operation, something achievable by power trace analysis, and that the two frequency should be preferably be phase-aligned \citep{glitches_paper}. In our attack scenario suppose the firmware we would like to dump has at some point an \texttt{OUT p} instruction, i.e. it outputs a memory location to port \texttt{p}, and runs on some loop. Since it is less complicated to exploit program flow rather than data flow \citep{glitches_paper}, we would attempt to skip the branch instruction on the check of each loop. The AVR assembly for your typical  \texttt{while(\emph{condition}) \{code\}} loop is shown in \ref{tab:while}, along with the cycles that each instruction takes \citep{atmega_manual}.

\begin{table}
\caption{\footnotesize A typical while loop of the form \texttt{while(\emph{i < n}) \{ code ;\}}.}
\label{tab:while}
\center
\begin{tabular}{ l l l }
&LDI R16, 4 & ; initialize n, 1 cycle\\
&LDI R17, 0 & ; initialize i, 1 cycle \\
loop :  & & ; label\\
& \dots code loading from  &\\
& memory to variable \dots & k cycles\\

& INC R17 & ; increment i, 1 cycle \\
& OUT \$18, R17 & ; output to port B\\
& SUB R16, R17 & ; n-i, result affects ZF bit of SREG.\\
& BREQ loop & ; if ZF = 0 branch to loop\\
& \dots other code \dots & \\
\end{tabular}
\end{table}

Retrieve crypto material via DPA.
