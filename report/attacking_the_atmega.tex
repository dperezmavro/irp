\section{Attacking The ATmega}
\label{sec:attacking_mega}

In this section we present the suggested attack that should work against the ATmega644. We believe that someone with a modest level of competence in electronics could successfully bypass the security fuse and lock-bit protections on the ATmega644 board, as researches have succeeded in bypassing the protection imposed by the AVR family in numerous ways. All researches used non-invasive attacks in order to achieve this since there is no need for more sophisticated attacks.Clock glitch attacks against AVR chips were successfully applied by Balasch et al. \citep{glitches_paper} against an ATmega163 and by O'Flynn et al. \citep{chipwhisperer} against an ATmega328P and Kizhvatov \citep{avr_mega} managed to retrieve AES and DES cryptographic keys from an ATmega16 and ATXmega128A1. Furthermore, Skorobogatov \citep{sergei:thesis} also points out that AVR MCUs are susceptible to glitch attacks due to the implementation of their security fuses. 

The suggested attack method will closely follow Balasch et al. \citep{glitches_paper}, further supported by results from other research as well. We will be a Class-I attacker performing a non-invasive clock-glitch attack. The equipment we have access to can be found in any descent university's electronics laboratory and our information regarding the chip will come from datasheets. We believe that the attack engineered by Balasch et al. \citep{glitches_paper} on the ATmega163 can be ported over to the ATmega644 due to their similarities. Both devices belong to the same family and by comparing their datasheets we can see that the 644 possesses all the hardware features that make the attack possible on the 163, namely it operates on an external clock signal and has a two stage pipeline\citep{glitches_paper}. Furthermore, the two devices have an almost identical, small, instruction set with instructions taking a maximum of 5 cycle to execute.

The attack should be tailored to a particular goal and hence we should distinguish between recovering cryptographic material from manipulating program or data flow. Subtleties that should be noted include that the glitch attack should be synchronized with the devices operation, achievable by power trace analysis like in  Fig.~\ref{fig:des_power} where one can see when DES encryption begins, and that the two frequencies should preferably be phase-aligned \citep{glitches_paper}\citep{sergei:thesis}\citep{avr_mega}. 

Performing a clock-glitch attack for corrupting the program or data flow by the ATmega644 would require locating when this happens and then exploiting it. In our attack scenario suppose the firmware we would like to dump has at some point an \texttt{OUT p} instruction, i.e. it outputs a memory location to port \texttt{p}, and runs on some loop (both reasonable assumptions). Since it is less complicated to exploit program flow rather than data flow \citep{glitches_paper}, we would attempt to skip the branch instruction on the check of each loop. The AVR assembly for your typical  \texttt{while(\emph{condition}) \{code\}} loop is shown in Table~\ref{tab:while}, along with the cycles that each instruction takes \citep{atmega_manual}. Even if we don't know the exact length of the loop, one could monitor how long it takes between successive outputs to port \$18 (i.e. our trigger event) and from that time estimate the cycle count, perhaps aided by correlating with the power trace, in order to synchronise target and attack host. Since it is easier to inject faults on multi-cycle instructions that perform the pre-fetching stage on their last execution cycle \citep{glitches_paper} like \texttt{BREQ} does, on could target \texttt{BREQ} in order to alter the resulting branch. Clock glitching on single-cycle instructions has the effect of replacing the following instruction with a \texttt{NOP} \citep{glitches_paper} and hence one could target the \texttt{OUT} instruction to skip over the \texttt{INC} instruction and continue outputting the memory.

For obtaining cryptographic material a similar approach could be taken, where one could effectively \texttt{NOP}-out further rounds of the cryptographic algorithm and brute-force the results of the first few \citep{glitches_paper}\citep{sergei:thesis} or corrupt multiplication results when modulo products are being computed and make factorization easier\citep{anderson:cautionary_note}. This could be done in either a while-loop implementation of the cryptographic rounds or an unrolled version of the code \citep{glitches_paper}. Another successful approach for obtaining access to cryptographic material would be power analysis, either SPA or DPA. For a DPA key extraction we would feed the AVR a big number of plain-texts and measure its power consumption,  \red{write some more about DPA attack . inserting a resistor in series with the MCU's power or ground, for avoiding noise \citep{sergei:thesis}}

\begin{table}
\caption{\footnotesize AVR assembler of  a typical while loop of the form \texttt{while(\emph{i < n}) \{ code ;\}}.}
\label{tab:while}
\center
\begin{tabular}{ l l l }
& \dots other code \dots & \\
&\texttt{LDI R16, 4 }& ; initialize n, 1 cycle\\
&\texttt{LDI R17, 0 }& ; initialize i, 1 cycle \\
condition : &&  ; label\\
& \texttt{SUB R16, R17 }& ; n-i, result affects ZF bit of SREG.\\
& \texttt{BREQ leave} & ; if ZF = 0 branch to loop,\\
& &  ; 1 cycle if false condition else 2\\
loop :  & & ; label\\
& \dots code loading from  &\\
& memory to variable \dots & ; k cycles\\
& \texttt{OUT \$18, R17} & ; output to port B\\
& \texttt{INC R17 }& ; increment i, 1 cycle \\
& \texttt{JMP condition }& ; 3 cycles \\
leave : && ; label \\
& \dots other code \dots & \\
\end{tabular}
\end{table}

It should be noted that Balasch et al. \citep{glitches_paper} observed a stuck-to-zero trend while corrupting multi-cycle instructions and even though the exact glitch period required to induce a fault might vary between boards, the faults  induced are deterministic, i.e. for a given chip and a given glitch period the same fault will always occur. Balasch et al. \citep{glitches_paper} also observed that the result of the glitch is highly dependent on the current instructions executing, the pre-fetched instructions and the glitch period, but even if the glitch results in an invalid op-code being fed to the CPU then the CPU will treat it as a \texttt{NOP} . 